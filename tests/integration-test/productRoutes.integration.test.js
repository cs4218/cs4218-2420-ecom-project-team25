// integration tests for product routes
import { MongoMemoryServer } from 'mongodb-memory-server';
import { requireSignIn, isAdmin } from '../../middlewares/authMiddleware';
import app from '../../app';
import mongoose from 'mongoose';
import slugify from 'slugify';
import braintree from 'braintree';

import productModel from '../../models/productModel';
import categoryModel from '../../models/categoryModel';
import orderModel from '../../models/orderModel';

const request = require('supertest');

// generated by GitHub Copilot
jest.mock('../../middlewares/authMiddleware.js', () => ({
  __esModule: true,
  requireSignIn: jest.fn(),
  isAdmin: jest.fn(),
}));

jest.mock('../../config/db.js', () => jest.fn());

jest.mock('braintree', () => ({
  BraintreeGateway: jest.fn(() => {
    return {
      clientToken: {
        generate: jest.fn(),
      },
      transaction: {
        sale: jest.fn(),
      },
    };
  }),
  Environment: {
    Sandbox: 'sandbox',
  },
}));

// references https://medium.com/@rosendomartinez270/testing-with-mongodb-memory-server-w-mongoose-42c9b256a60f
// and https://github.com/typegoose/mongodb-memory-server/issues/421
// and heavily references GitHub Copilot
let mongoMock;
const categoryId = '66db427fdb0119d9234b27ef';
const categoryIdAlternative = '67b0435e17b12d49bd701102';
const userId = '679df17ea7eff1d4847d568d';

// get the gateway object
const gateway = braintree.BraintreeGateway.mock.results[0].value;

beforeAll(async () => {
  mongoMock = await MongoMemoryServer.create();
  process.env = { MONGO_URL: mongoMock.getUri() };
  await mongoose.connect(process.env.MONGO_URL);
  await mongoose.connection.db.dropDatabase();
}, 20000);

afterAll(async () => {
  await mongoose.connection.db.dropDatabase();
  await mongoose.disconnect();
  await mongoMock.stop();
}, 20000);

describe('Create Product Route', () => {
  beforeEach(async () => {
    jest.clearAllMocks();
  });

  afterEach(async () => {
    await productModel.deleteMany();
    await mongoose.connection.db.dropDatabase();
  });

  it('should fail if user is not an admin', async () => {
    isAdmin.mockImplementation((req, res, next) => {
      return res.status(401).send({
        success: false,
        message: 'UnAuthorized Access',
      });
    });

    requireSignIn.mockImplementation((req, res, next) => {
      next();
    });

    const response = await request(app)
      .post('/api/v1/product/create-product')
      .expect(401)
      .then((res) => {
        expect(res.body).toEqual({
          success: false,
          message: 'UnAuthorized Access',
        });
      });
  });

  it('should fail if the user is not signed in', async () => {
    isAdmin.mockImplementation((req, res, next) => {
      next();
    });

    requireSignIn.mockImplementation((req, res, next) => {
      return res.status(401).send({
        success: false,
        message: 'UnAuthorized Access',
      });
    });

    await request(app)
      .post('/api/v1/product/create-product')
      .expect(401)
      .then((res) => {
        expect(res.body).toEqual({
          success: false,
          message: 'UnAuthorized Access',
        });
      });
  });

  it('should fail if the user is signed in and is an admin but request is empty', async () => {
    isAdmin.mockImplementation((req, res, next) => {
      next();
    });

    requireSignIn.mockImplementation((req, res, next) => {
      next();
    });

    await request(app).post('/api/v1/product/create-product').expect(500);
  });

  it('should succeed if user is signed in and is an admin and request is not empty', async () => {
    isAdmin.mockImplementation((req, res, next) => {
      next();
    });

    requireSignIn.mockImplementation((req, res, next) => {
      next();
    });

    await request(app)
      .post('/api/v1/product/create-product')
      .field('name', 'product')
      .field('description', 'product description')
      .field('price', 100)
      .field('category', '66db427fdb0119d9234b27ef')
      .field('quantity', 10)
      .field('shipping', true)
      .expect(201);

    const product = await productModel.findOne({ name: 'product' });
    expect(product.name).toEqual('product');
    expect(product.description).toEqual('product description');
    expect(product.price).toEqual(100);
    expect(product.category.toString()).toEqual(categoryId);
    expect(product.quantity).toEqual(10);
    expect(product.shipping).toEqual(true);
  });
});

describe('Update Product Route', () => {
  beforeEach(async () => {
    jest.clearAllMocks();
  });

  afterEach(async () => {
    await productModel.deleteMany();
    await mongoose.connection.db.dropDatabase();
  });

  it('should fail if user is not an admin', async () => {
    isAdmin.mockImplementation((req, res, next) => {
      return res.status(401).send({
        success: false,
        message: 'UnAuthorized Access',
      });
    });

    requireSignIn.mockImplementation((req, res, next) => {
      next();
    });

    await request(app)
      .put('/api/v1/product/update-product/67b486bea548a5ec8d28a519')
      .expect(401)
      .then((res) => {
        expect(res.body).toEqual({
          success: false,
          message: 'UnAuthorized Access',
        });
      });
  });

  it('should fail if the user is not signed in', async () => {
    isAdmin.mockImplementation((req, res, next) => {
      next();
    });

    requireSignIn.mockImplementation((req, res, next) => {
      return res.status(401).send({
        success: false,
        message: 'UnAuthorized Access',
      });
    });

    await request(app)
      .put('/api/v1/product/update-product/67b486bea548a5ec8d28a519')
      .expect(401)
      .then((res) => {
        expect(res.body).toEqual({
          success: false,
          message: 'UnAuthorized Access',
        });
      });
  });

  it('should fail if the user is signed in and is an admin but request is empty', async () => {
    isAdmin.mockImplementation((req, res, next) => {
      next();
    });

    requireSignIn.mockImplementation((req, res, next) => {
      next();
    });

    await request(app)
      .put('/api/v1/product/update-product/67b486bea548a5ec8d28a519')
      .expect(500);
  });

  it('should succeed if user is signed in and is an admin and request is not empty', async () => {
    // setup the mocks and initial product
    isAdmin.mockImplementation((req, res, next) => {
      next();
    });

    requireSignIn.mockImplementation((req, res, next) => {
      next();
    });

    const product = await new productModel({
      name: 'product',
      description: 'product description',
      price: 100,
      category: categoryId,
      quantity: 10,
      shipping: true,
      slug: slugify('product'),
    }).save();

    const productId = product._id.toString();

    // test the integration
    await request(app)
      .put('/api/v1/product/update-product/' + productId)
      .field('name', product.name)
      .field('description', product.description)
      .field('price', 200)
      .field('category', categoryId)
      .field('quantity', product.quantity)
      .field('shipping', product.shipping)
      .expect(201);

    // make sure the product is updated
    const updatedProduct = await productModel.findOne({ _id: productId });
    expect(updatedProduct.name).toEqual(product.name);
    expect(updatedProduct.description).toEqual(product.description);
    expect(updatedProduct.price).toEqual(200);
    expect(updatedProduct.category.toString()).toEqual(categoryId);
    expect(updatedProduct.quantity).toEqual(product.quantity);
    expect(updatedProduct.shipping).toEqual(product.shipping);
  }, 20000);
});

describe('Get Product Route', () => {
  let product;

  beforeEach(async () => {
    jest.clearAllMocks();

    product = await new productModel({
      name: 'product',
      description: 'product description',
      price: 100,
      category: categoryId,
      quantity: 10,
      shipping: true,
      slug: slugify('product'),
    }).save();
  });

  afterEach(async () => {
    await productModel.deleteMany();
    await mongoose.connection.db.dropDatabase();
  });

  it('should return a list of products', async () => {
    const response = await request(app)
      .get('/api/v1/product/get-product')
      .expect(200);

    expect(response.body.success).toEqual(true);
    expect(response.body.counTotal).toEqual(1);
    expect(response.body.products.length).toEqual(1);
    expect(response.body.products[0].name).toEqual(product.name);
    expect(response.body.products[0].description).toEqual(product.description);
    expect(response.body.products[0].price).toEqual(product.price);
    expect(response.body.products[0].category).toEqual(null); // TODO: why is this null?
    expect(response.body.products[0].quantity).toEqual(product.quantity);
    expect(response.body.products[0].shipping).toEqual(product.shipping);
  });

  it('should return an empty list if there are no products', async () => {
    await productModel.deleteMany();
    const response = await request(app)
      .get('/api/v1/product/get-product')
      .expect(200);

    expect(response.body.success).toEqual(true);
    expect(response.body.counTotal).toEqual(0);
    expect(response.body.products.length).toEqual(0);
  });
});

describe('Get Product with Slug Route', () => {
  let product;
  let productId;
  const productSlug = 'product';

  beforeEach(async () => {
    jest.clearAllMocks();

    product = await new productModel({
      name: 'product',
      description: 'product description',
      price: 100,
      category: categoryId,
      quantity: 10,
      shipping: true,
      slug: slugify(productSlug),
    }).save();

    productId = product._id.toString();
  });

  afterEach(async () => {
    await productModel.deleteMany();
    await mongoose.connection.db.dropDatabase();
  });

  it('should return a single product', async () => {
    const response = await request(app)
      .get('/api/v1/product/get-product/' + productSlug)
      .expect(200);

    expect(response.body.success).toEqual(true);
    expect(response.body.product.name).toEqual(product.name);
    expect(response.body.product.description).toEqual(product.description);
    expect(response.body.product.price).toEqual(product.price);
    expect(response.body.product.category).toEqual(null); // TODO: why is this null?
    expect(response.body.product.quantity).toEqual(product.quantity);
    expect(response.body.product.shipping).toEqual(product.shipping);
  });

  it('should error out if the product does not exist', async () => {
    // use categoryId as a stand-in for a non-existent product
    const response = await request(app)
      .get('/api/v1/product/get-product/' + categoryId)
      .expect(200);

    // TODO: why is this a 200? shouldn't it be a 404?
    expect(response.body.success).toEqual(true);
    expect(response.body.message).toEqual('Single Product Fetched');
    expect(response.body.product).toEqual(null);
  });
});

describe('Get Product Photo Route', () => {
  let product;
  let productId;
  const productSlug = 'product';

  beforeEach(async () => {
    jest.clearAllMocks();

    product = await new productModel({
      name: 'product',
      description: 'product description',
      price: 100,
      category: categoryId,
      quantity: 10,
      shipping: true,
      slug: slugify(productSlug),
      photo: {
        data: {
          data: [1, 2, 3, 4],
          type: 'Buffer',
        },
        contentType: 'image/png',
      },
    }).save();

    productId = product._id.toString();
  });

  afterEach(async () => {
    await productModel.deleteMany();
    await mongoose.connection.db.dropDatabase();
  });

  it('should return a photo', async () => {
    const response = await request(app)
      .get('/api/v1/product/product-photo/' + productId)
      .expect(200);

    expect(response.body).toEqual(Buffer.from([1, 2, 3, 4]));
  });

  it('should send internal error if the product has no images', async () => {
    await productModel.updateOne(
      { _id: productId },
      { $unset: { photo: null } }
    );

    const response = await request(app)
      .get('/api/v1/product/product-photo/' + productId)
      .expect(500);
  });
});

describe('Delete Product Route', () => {
  let product;
  let productId;
  const productSlug = 'product';

  beforeEach(async () => {
    jest.clearAllMocks();

    product = await new productModel({
      name: 'product',
      description: 'product description',
      price: 100,
      category: categoryId,
      quantity: 10,
      shipping: true,
      slug: slugify(productSlug),
    }).save();

    productId = product._id.toString();
  });

  afterEach(async () => {
    await productModel.deleteMany();
    await mongoose.connection.db.dropDatabase();
  });

  it('should delete a product', async () => {
    const response = await request(app)
      .delete('/api/v1/product/delete-product/' + productId)
      .expect(200);

    expect(response.body.success).toEqual(true);
    expect(response.body.message).toEqual('Product Deleted Successfully');

    expect(await productModel.findOne({ _id: productId })).toEqual(null);
  });

  it('should error out if the requested product is not found', async () => {
    // use categoryId as a stand-in for a non-existent product
    // TODO: why is this a 200? shouldn't it be a 404?
    const response = await request(app)
      .delete('/api/v1/product/delete-product/' + categoryId)
      .expect(200);

    expect(response.body.success).toEqual(true);
    expect(response.body.message).toEqual('Product Deleted Successfully');
  });
});

describe('Filter Product Route', () => {
  let productOne;
  let productTwo;
  let productIdOne;
  let productIdTwo;
  const productSlug = 'product';

  beforeEach(async () => {
    jest.clearAllMocks();

    productOne = await new productModel({
      name: 'product',
      description: 'product description',
      price: 100,
      category: categoryId,
      quantity: 10,
      shipping: true,
      slug: slugify(productSlug),
    }).save();

    productIdOne = productOne._id.toString();

    productTwo = await new productModel({
      name: 'product two',
      description: 'product two description',
      price: 1000000000000,
      category: categoryIdAlternative,
      quantity: 10,
      shipping: true,
      slug: slugify(productSlug),
    }).save();

    productIdTwo = productTwo._id.toString();
  });

  afterEach(async () => {
    await productModel.deleteMany();
    await mongoose.connection.db.dropDatabase();
  });

  it('should filter out products', async () => {
    const response = await request(app)
      .post('/api/v1/product/product-filters')
      .send({
        checked: [categoryId],
        radio: [100, 1000],
      })
      .expect(200);

    expect(response.body.success).toEqual(true);
    expect(response.body.products.length).toEqual(1);
    expect(response.body.products[0].name).toEqual(productOne.name);
    expect(response.body.products[0].description).toEqual(
      productOne.description
    );
    expect(response.body.products[0].price).toEqual(productOne.price);
    expect(response.body.products[0].category.toString()).toEqual(categoryId);
    expect(response.body.products[0].quantity).toEqual(productOne.quantity);
    expect(response.body.products[0].shipping).toEqual(productOne.shipping);
  });

  it('should filter out products if checked is empty', async () => {
    const response = await request(app)
      .post('/api/v1/product/product-filters')
      .send({
        checked: [],
        radio: [100, 1000],
      })
      .expect(200);

    expect(response.body.success).toEqual(true);
    expect(response.body.products.length).toEqual(1);
    expect(response.body.products[0].name).toEqual(productOne.name);
    expect(response.body.products[0].description).toEqual(
      productOne.description
    );
    expect(response.body.products[0].price).toEqual(productOne.price);
    expect(response.body.products[0].category.toString()).toEqual(categoryId);
    expect(response.body.products[0].quantity).toEqual(productOne.quantity);
    expect(response.body.products[0].shipping).toEqual(productOne.shipping);
  });

  it('should filter out products if radio is empty', async () => {
    const response = await request(app)
      .post('/api/v1/product/product-filters')
      .send({
        radio: [100000, 10000000000000000],
        checked: [],
      })
      .expect(200);

    expect(response.body.success).toEqual(true);
    expect(response.body.products.length).toEqual(1);
    expect(response.body.products[0].name).toEqual(productTwo.name);
    expect(response.body.products[0].description).toEqual(
      productTwo.description
    );
    expect(response.body.products[0].price).toEqual(productTwo.price);
    expect(response.body.products[0].category.toString()).toEqual(
      categoryIdAlternative
    );
    expect(response.body.products[0].quantity).toEqual(productTwo.quantity);
    expect(response.body.products[0].shipping).toEqual(productTwo.shipping);
  });
});

describe('Get Product Count Route', () => {
  let product;
  let productId;
  const productSlug = 'product';

  beforeEach(async () => {
    jest.clearAllMocks();

    product = await new productModel({
      name: 'product',
      description: 'product description',
      price: 100,
      category: categoryId,
      quantity: 10,
      shipping: true,
      slug: slugify(productSlug),
    }).save();

    productId = product._id.toString();
  });

  afterEach(async () => {
    await productModel.deleteMany();
    await mongoose.connection.db.dropDatabase();
  });

  it('should return the correct count', async () => {
    const response = await request(app)
      .get('/api/v1/product/product-count')
      .expect(200);

    expect(response.body.success).toEqual(true);
    expect(response.body.total).toEqual(1);
  });
});

describe('Search Product By Keyword Route', () => {
  let productOne;
  let productTwo;
  let productIdOne;
  let productIdTwo;
  const productSlug = 'product';

  beforeEach(async () => {
    jest.clearAllMocks();

    productOne = await new productModel({
      name: 'amazing product',
      description: 'amazing product description',
      price: 100,
      category: categoryId,
      quantity: 10,
      shipping: true,
      slug: slugify(productSlug),
    }).save();

    productIdOne = productOne._id.toString();

    productTwo = await new productModel({
      name: 'pricey product',
      description: 'very very pricey product',
      price: 1000000000000,
      category: categoryIdAlternative,
      quantity: 10,
      shipping: true,
      slug: slugify(productSlug),
    }).save();

    productIdTwo = productTwo._id.toString();
  });

  afterEach(async () => {
    await productModel.deleteMany();
    await mongoose.connection.db.dropDatabase();
  });

  it('should correctly find products by product name', async () => {
    const response = await request(app)
      .get('/api/v1/product/search/' + productOne.name)
      .expect(200);

    expect(response.body.length).toEqual(1);
    expect(response.body[0].name).toEqual(productOne.name);
    expect(response.body[0].description).toEqual(productOne.description);
    expect(response.body[0].price).toEqual(productOne.price);
    expect(response.body[0].category.toString()).toEqual(categoryId);
    expect(response.body[0].quantity).toEqual(productOne.quantity);
    expect(response.body[0].shipping).toEqual(productOne.shipping);
  });

  it('should correctly find products by product description', async () => {
    const response = await request(app)
      .get('/api/v1/product/search/' + 'very very pricey')
      .expect(200);

    expect(response.body.length).toEqual(1);
    expect(response.body[0].name).toEqual(productTwo.name);
    expect(response.body[0].description).toEqual(productTwo.description);
    expect(response.body[0].price).toEqual(productTwo.price);
    expect(response.body[0].category.toString()).toEqual(categoryIdAlternative);
    expect(response.body[0].quantity).toEqual(productTwo.quantity);
    expect(response.body[0].shipping).toEqual(productTwo.shipping);
  });

  it('should correctly find products by product name and description', async () => {
    const response = await request(app)
      .get('/api/v1/product/search/' + 'product')
      .expect(200);

    expect(response.body.length).toEqual(2);
    expect(response.body[0].name).toEqual(productOne.name);
    expect(response.body[0].description).toEqual(productOne.description);
    expect(response.body[0].price).toEqual(productOne.price);
    expect(response.body[0].category.toString()).toEqual(categoryId);
    expect(response.body[0].quantity).toEqual(productOne.quantity);
    expect(response.body[0].shipping).toEqual(productOne.shipping);

    expect(response.body[1].name).toEqual(productTwo.name);
    expect(response.body[1].description).toEqual(productTwo.description);
    expect(response.body[1].price).toEqual(productTwo.price);
    expect(response.body[1].category.toString()).toEqual(categoryIdAlternative);
    expect(response.body[1].quantity).toEqual(productTwo.quantity);
    expect(response.body[1].shipping).toEqual(productTwo.shipping);
  });

  it('should return an empty list if no products are found', async () => {
    const response = await request(app)
      .get('/api/v1/product/search/' + 'hambuger')
      .expect(200);

    expect(response.body.length).toEqual(0);
  });

  it('should error out if the keyword is empty', async () => {
    const response = await request(app)
      .get('/api/v1/product/search/' + '')
      .expect(404);
  });
});

describe('Get Related Product Route', () => {
  let productOne;
  let productTwo;
  let productThree;
  let productIdOne;
  let productIdTwo;
  let productIdThree;
  const productSlug = 'product';

  beforeEach(async () => {
    jest.clearAllMocks();

    productOne = await new productModel({
      name: 'amazing product',
      description: 'amazing product description',
      price: 100,
      category: categoryId,
      quantity: 10,
      shipping: true,
      slug: slugify(productSlug),
    }).save();

    productIdOne = productOne._id.toString();

    productTwo = await new productModel({
      name: 'pricey product',
      description: 'very very pricey product',
      price: 1000000000000,
      category: categoryIdAlternative,
      quantity: 10,
      shipping: true,
      slug: slugify(productSlug),
    }).save();

    productIdTwo = productTwo._id.toString();

    productThree = await new productModel({
      name: 'cheap product',
      description: 'very very cheap product',
      price: 1,
      category: categoryId,
      quantity: 10,
      shipping: true,
      slug: slugify(productSlug),
    }).save();

    productIdThree = productThree._id.toString();
  });

  afterEach(async () => {
    await productModel.deleteMany();
    await mongoose.connection.db.dropDatabase();
  });

  it('should return related products', async () => {
    const response = await request(app)
      .get('/api/v1/product/related-product/' + productIdOne + '/' + categoryId)
      .expect(200);

    // should return product three
    expect(response.body.success).toEqual(true);
    expect(response.body.products.length).toEqual(1);
    expect(response.body.products[0].name).toEqual(productThree.name);
    expect(response.body.products[0].description).toEqual(
      productThree.description
    );
    expect(response.body.products[0].price).toEqual(productThree.price);
    expect(response.body.products[0].category).toEqual(null); // TODO: why is this null?
    expect(response.body.products[0].quantity).toEqual(productThree.quantity);
    expect(response.body.products[0].shipping).toEqual(productThree.shipping);
  });

  it('should return an empty list if no related products are found', async () => {
    const response = await request(app)
      .get(
        '/api/v1/product/related-product/' +
          productIdTwo +
          '/' +
          categoryIdAlternative
      )
      .expect(200);

    expect(response.body.success).toEqual(true);
    expect(response.body.products.length).toEqual(0);
  });
});

describe('Get Product Category Route', () => {
  let productOne;
  let productIdOne;
  let categoryOne;
  let categorySlug = 'amazing';
  const productSlug = 'product';

  beforeEach(async () => {
    jest.clearAllMocks();

    categoryOne = await new categoryModel({
      name: 'Amazing Category',
      slug: categorySlug,
    }).save();

    productOne = await new productModel({
      name: 'amazing product',
      description: 'amazing product description',
      price: 100,
      category: categoryOne._id.toString(),
      quantity: 10,
      shipping: true,
      slug: slugify(productSlug),
    }).save();

    productIdOne = productOne._id.toString();
  });

  afterEach(async () => {
    await productModel.deleteMany();
    await mongoose.connection.db.dropDatabase();
  });

  it('should return correct product given a category', async () => {
    const response = await request(app)
      .get('/api/v1/product/product-category/' + categorySlug)
      .expect(200);

    expect(response.body.success).toEqual(true);
    expect(response.body.category._id).toEqual(categoryOne._id.toString());
    expect(response.body.category.name).toEqual(categoryOne.name);
    expect(response.body.category.slug).toEqual(categoryOne.slug);

    expect(response.body.products.length).toEqual(1);
    expect(response.body.products[0].name).toEqual(productOne.name);
    expect(response.body.products[0].description).toEqual(
      productOne.description
    );
    expect(response.body.products[0].price).toEqual(productOne.price);
    expect(response.body.products[0].category._id).toEqual(
      categoryOne._id.toString()
    );
    expect(response.body.products[0].category.name).toEqual(categoryOne.name);
    expect(response.body.products[0].category.slug).toEqual(categoryOne.slug);
    expect(response.body.products[0].quantity).toEqual(productOne.quantity);
    expect(response.body.products[0].shipping).toEqual(productOne.shipping);
  });
});

// references https://chatgpt.com/share/67d51d6c-3f64-8004-8213-e62ee21aa907
describe('Braintree Token Generation Route', () => {
  beforeEach(async () => {
    jest.clearAllMocks();
  });

  it('should generate a token', async () => {
    // mock the return values
    gateway.clientToken.generate.mockImplementation((item, func) => {
      return func(null, 'fake-token');
    });

    const response = await request(app)
      .get('/api/v1/product/braintree/token')
      .expect(200);

    expect(response.text).toEqual('fake-token');
  });

  it('should error out if token generation fails', async () => {
    const error = 'error';

    gateway.clientToken.generate.mockImplementation((item, func) => {
      return func(error, null);
    });

    const response = await request(app)
      .get('/api/v1/product/braintree/token')
      .expect(500);

    expect(response.text).toEqual(error);
  });
});

// references https://chatgpt.com/share/67d51d6c-3f64-8004-8213-e62ee21aa907
describe('Braintree Payment Route', () => {
  let emptyCart;
  let mockedCart;

  beforeEach(async () => {
    jest.clearAllMocks();

    emptyCart = [];
    mockedCart = [
      await new productModel({
        name: 'product',
        description: 'product description',
        price: 100,
        category: categoryId,
        quantity: 10,
        shipping: true,
        slug: slugify('product'),
      }).save(),
    ];
  });

  it('should error out if user is not authenticated', async () => {
    // mock the return values
    gateway.transaction.sale.mockImplementation((item, func) => {
      func({ success: true });
    });

    const response = await request(app)
      .post('/api/v1/product/braintree/payment')
      .send({
        nonce: 'fake-nonce',
        cart: [],
      })
      .expect(500);
  });

  it('should error out if an order with zero items in cart is submitted', async () => {
    // mock the return values
    gateway.transaction.sale.mockImplementation((item, func) => {
      func(null, { success: true });
    });

    requireSignIn.mockImplementation((req, res, next) => {
      req.user = {
        _id: userId,
      };

      next();
    });

    const response = await request(app)
      .post('/api/v1/product/braintree/payment')
      .send({
        nonce: 'fake-nonce',
        cart: emptyCart,
      })
      .expect(500);

    expect(response.body).toEqual({ error: 'Cart is empty' });
  });

  it('should not error out if an order with items in cart is submitted', async () => {
    // mock the return values
    gateway.transaction.sale.mockImplementation((item, func) => {
      func(null, { success: true });
    });

    requireSignIn.mockImplementation((req, res, next) => {
      req.user = {
        _id: userId,
      };

      next();
    });

    const response = await request(app)
      .post('/api/v1/product/braintree/payment')
      .send({
        nonce: 'fake-nonce',
        cart: mockedCart,
      })
      .expect(200);

    expect(response.body).toEqual({ ok: true });

    const order = await orderModel.findOne({ buyer: userId });
    expect(order).not.toEqual(null);
    expect(order.products.length).toEqual(1);
    expect(order.products[0].toString()).toEqual(mockedCart[0]._id.toString());
    expect(order.payment.success).toEqual(true);
    expect(order.buyer.toString()).toEqual(userId);
  });
});
